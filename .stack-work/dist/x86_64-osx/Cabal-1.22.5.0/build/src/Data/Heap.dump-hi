
==================== FINAL INTERFACE ====================
2016-02-08 18:15:28.82898 UTC

interface heaps_D84gs2t4foVLGrEFu7URZk:Data.Heap 7103
  interface hash: 12a86afade0ade182be3c8785b02fcc2
  ABI hash: c316440dee0b0f6f3d5c9bb0d94acc61
  export-list hash: 72654de8a7eb46b0acfe1267160e71ea
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 18431fa22569a6146ee5b9f2660a772f
  sig of: Nothing
  used TH splices: False
  where
exports:
  Data.Heap.fromList
  Data.Heap.toList
  Data.Heap.BinaryHeap
  Data.Heap.Heap{Data.Heap.empty Data.Heap.insert Data.Heap.isEmpty Data.Heap.remove Data.Heap.value}
  Data.Heap.Policy{Data.Heap.Max Data.Heap.Min}
module dependencies: Data.Tree
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  Data.Tree 9d66cae20ece06ae4f87f05558fc5f20
  exports: 046b59743458e083a149366fc880a86c
  BinaryTree 1858445b33a234e30535076559c21dfc
7170b7ff5fec092231c5184299d62f4a
  $fShowPolicy :: GHC.Show.Show Data.Heap.Policy
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Data.Heap.Policy
                  Data.Heap.$fShowPolicy_$cshowsPrec
                  Data.Heap.$fShowPolicy_$cshow
                  Data.Heap.$fShowPolicy_$cshowList -}
7170b7ff5fec092231c5184299d62f4a
  $fShowPolicy1 :: Data.Heap.Policy -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Data.Heap.Policy eta :: GHC.Base.String ->
                 case ds of wild {
                   Data.Heap.Max
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Data.Heap.$fShowPolicy3)
                        eta
                   Data.Heap.Min
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Data.Heap.$fShowPolicy2)
                        eta }) -}
5cebb5920b73f4b4b75c38b26a382fb5
  $fShowPolicy2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Min"#) -}
47de50a6d4779b58e2b8138d4f534533
  $fShowPolicy3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Max"#) -}
7170b7ff5fec092231c5184299d62f4a
  $fShowPolicy_$cshow :: Data.Heap.Policy -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Data.Heap.Policy ->
                 case x of wild {
                   Data.Heap.Max -> Data.Heap.$fShowPolicy3
                   Data.Heap.Min -> Data.Heap.$fShowPolicy2 }) -}
7170b7ff5fec092231c5184299d62f4a
  $fShowPolicy_$cshowList :: [Data.Heap.Policy] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Data.Heap.Policy
                   Data.Heap.$fShowPolicy1) -}
7170b7ff5fec092231c5184299d62f4a
  $fShowPolicy_$cshowsPrec ::
    GHC.Types.Int -> Data.Heap.Policy -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: Data.Heap.Policy
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   Data.Heap.Max
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Data.Heap.$fShowPolicy3)
                        eta
                   Data.Heap.Min
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Data.Heap.$fShowPolicy2)
                        eta }) -}
c6706fc54da84cb03856b41e78dcdc65
  class (Data.Tree.BinaryTree bh, Data.Heap.Heap bh) =>
        BinaryHeap (bh :: * -> *)
59402278e0e614775a420ce522ce481b
  class Heap (h :: * -> *) where
    empty :: Data.Heap.Policy -> h a
    isEmpty :: h a -> GHC.Types.Bool
    value :: h a -> GHC.Base.Maybe a
    insert :: GHC.Classes.Ord a => a -> h a -> h a
    remove :: GHC.Classes.Ord a => h a -> (GHC.Base.Maybe a, h a)
7170b7ff5fec092231c5184299d62f4a
  data Policy = Max | Min
    Promotable
ab0ba67986af954a01dd60aeb8fcb09e
  fromList ::
    (Data.Heap.Heap h, GHC.Classes.Ord a) =>
    Data.Heap.Policy -> [a] -> h a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(1*C1(U),A,A,1*C1(U),A)><L,U><L,U>,
     Unfolding: (\ @ a
                   @ (h :: * -> *)
                   $dHeap :: Data.Heap.Heap h
                   $dOrd :: GHC.Classes.Ord a
                   policy :: Data.Heap.Policy ->
                 let {
                   k :: a -> h a -> h a = Data.Heap.insert @ h $dHeap @ a $dOrd
                 } in
                 let {
                   z :: h a = Data.Heap.empty @ h $dHeap @ a policy
                 } in
                 letrec {
                   go :: [a] -> h a {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [a] -> case ds of wild { [] -> z : y ys -> k y (go ys) }
                 } in
                 \ eta :: [a] -> go eta) -}
2626105d80a16563c60c3bce3b9c3558
  toList :: (Data.Heap.Heap h, GHC.Classes.Ord a) => h a -> [a]
  {- Arity: 3,
     Strictness: <S(LC(S)LLL),U(A,C(U),A,A,C(C1(U(U,U))))><L,U><L,U> -}
instance GHC.Show.Show [Data.Heap.Policy] = Data.Heap.$fShowPolicy
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

