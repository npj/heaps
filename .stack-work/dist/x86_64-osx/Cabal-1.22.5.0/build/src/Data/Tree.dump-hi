
==================== FINAL INTERFACE ====================
2016-02-08 18:15:28.715052 UTC

interface heaps_D84gs2t4foVLGrEFu7URZk:Data.Tree 7103
  interface hash: b8c9c01a8cc53962e57f490c30bcb0d2
  ABI hash: 9d66cae20ece06ae4f87f05558fc5f20
  export-list hash: 046b59743458e083a149366fc880a86c
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 18431fa22569a6146ee5b9f2660a772f
  sig of: Nothing
  used TH splices: False
  where
exports:
  Data.Tree.prettify
  Data.Tree.BinaryTree{Data.Tree.left Data.Tree.right}
  Data.Tree.Empty{Data.Tree.isEmpty Data.Tree.value}
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
1858445b33a234e30535076559c21dfc
  class Data.Tree.Empty t => BinaryTree (t :: * -> *) where
    left :: t a -> t a
    right :: t a -> t a
f2323d700eed924a6c33feb640997b30
  class Empty (t :: * -> *) where
    value :: t a -> GHC.Base.Maybe a
    isEmpty :: t a -> GHC.Types.Bool
b794910c658409195c7dbaeddc2328a4
  prettify ::
    (Data.Tree.BinaryTree t, GHC.Show.Show a) => t a -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U(1*U,C(U),C(U))><L,1*U(A,1*U,A)><L,U>,
     Unfolding: (\ @ (t :: * -> *)
                   @ a
                   $dBinaryTree :: Data.Tree.BinaryTree t
                   $dShow :: GHC.Show.Show a
                   eta :: t a ->
                 let {
                   f :: a -> GHC.Base.String = GHC.Show.show @ a $dShow
                 } in
                 let {
                   $dEmpty :: Data.Tree.Empty t
                   = Data.Tree.$p1BinaryTree @ t $dBinaryTree
                 } in
                 let {
                   g :: t a -> GHC.Base.Maybe a = Data.Tree.value @ t $dEmpty @ a
                 } in
                 letrec {
                   $wprettify' :: GHC.Prim.Int# -> t a -> [GHC.Types.Char]
                     {- Arity: 2, Strictness: <S,U><L,U>, Inline: [0] -}
                   = \ ww :: GHC.Prim.Int# w :: t a ->
                     let {
                       toString :: [GHC.Types.Char]
                       = GHC.Base.++
                           @ GHC.Types.Char
                           (f (case g w of wild {
                                 GHC.Base.Nothing -> Data.Maybe.fromJust1 @ a
                                 GHC.Base.Just x -> x }))
                           (GHC.Base.++
                              @ GHC.Types.Char
                              ($wprettify'
                                 (GHC.Prim.+# ww 2)
                                 (Data.Tree.left @ t $dBinaryTree @ a w))
                              ($wprettify'
                                 (GHC.Prim.+# ww 2)
                                 (Data.Tree.right @ t $dBinaryTree @ a w)))
                     } in
                     case ww of wild {
                       DEFAULT
                       -> GHC.CString.unpackAppendCString#
                            "\n"#
                            (let {
                               y :: GHC.Prim.Int# = GHC.Prim.-# wild 2
                             } in
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.<# 0 y) of wild1 {
                               GHC.Types.False -> GHC.CString.unpackAppendCString# "|-"# toString
                               GHC.Types.True
                               -> let {
                                    n :: [GHC.Types.Char]
                                    = GHC.CString.unpackAppendCString# "|-"# toString
                                  } in
                                  let {
                                    lvl :: [GHC.Types.Char]
                                    = GHC.Types.: @ GHC.Types.Char Data.Tree.prettify1 n
                                  } in
                                  letrec {
                                    $wxs :: GHC.Prim.Int# -> [GHC.Types.Char]
                                      {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                                    = \ ww1 :: GHC.Prim.Int# ->
                                      case ww1 of ds1 {
                                        DEFAULT
                                        -> GHC.Types.:
                                             @ GHC.Types.Char
                                             Data.Tree.prettify1
                                             ($wxs (GHC.Prim.-# ds1 1))
                                        1 -> lvl }
                                  } in
                                  $wxs y })
                       0 -> toString }
                 } in
                 $wprettify' 0 eta) -}
584fb007c772a04513d9dd3ad670f81d
  prettify1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# ' ') -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

